# How parseva-math builds a Homogeneous Abstract Syntax Tree
First, we need to tell ANTLR that we want to have it generate a visitor in `pom.xml`:

```xml

  <groupId>org.antlr</groupId>
                <artifactId>antlr4-maven-plugin</artifactId>
                <version>4.9.1</version>
                <configuration>
                    <visitor>true</visitor>
                    <listener>false</listener>
                    <inputEncoding>UTF-8</inputEncoding>
                    <sourceDirectory>
                        src/main/resources/parsevamath/tools/grammar
                    </sourceDirectory>
                </configuration>
```

Then, we generate the visitor and parser:

```bash

 mvn antlr4:antlr4

```

In the case of parseva-math, antlr generates two listeners, found in 
target/generated-sources:

```bash
├── assets
├── config
├── docs
├── LICENSE
├── pom.xml
├── README.md
├── src
└── target
    ├── checkstyle-cachefile
    ├── checkstyle-checker.xml
    ├── checkstyle-result.xml
    ├── classes
    ├── generated-sources
    │   ├── annotations
    │   └── antlr4
    │       ├── MathBaseVisitor.java
    │       ├── Math.interp
    │       ├── MathLexer.interp
    │       ├── MathLexer.java
    │       ├── MathLexer.tokens
    │       ├── MathParser.java
    │       ├── Math.tokens
    │       └── MathVisitor.java
    ├── maven-status
    ├── parseva-math-0.1-SNAPSHOT.jar
    ├── pmd
    ├── pmd.xml
    ├── site
    ├── spotbugsXml.xml
    └── test-classes


```

We are really only interested in `MathBaseVisitor.java`.  This java file generated by
ANTLR is comprised of one method per grammar rule or label, and we can override these 
methods to build out our AST. Example of method from MathBaseVisitor:

```java

@Override 
public T visitCompilationUnit(MathParser.CompilationUnitContext ctx) { return visitChildren(ctx); }

```

As you can see, unless overridden, these methods simply return the result of visiting the children.